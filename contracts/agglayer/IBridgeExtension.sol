// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IBridgeExtension
 * @notice Interface for the Bridge Extension contract
 * @custom:katana 0x64B20Eb25AEd030FD510EF93B9135278B152f6a6
 * @custom:tags agglayer,bridge,polygon,extension
 */
interface IBridgeExtension {
    error AddressEmptyCode(address target);
    error AddressInsufficientBalance(address account);
    error AlreadyClaimed();
    error AmountDoesNotMatchMsgValue();
    error BridgeAddressNotAllowed();
    error ClaimNotSet();
    error DestinationNetworkInvalid();
    error EmergencyStateNotAllowed();
    error EtherTransferFailed();
    error FailedInnerCall();
    error FailedProxyDeployment();
    error GasTokenNetworkMustBeZeroOnEther();
    error GlobalExitRootInvalid();
    error InputArraysLengthMismatch();
    error InvalidGlobalIndex();
    error InvalidInitializeFunction();
    error InvalidProxyAdmin(address proxyAdmin);
    error InvalidSmtProof();
    error InvalidSovereignWETHAddressParams();
    error InvalidZeroAddress();
    error InvalidZeroNetworkID();
    error InvalidZeroProxyAdminOwner(address proxyAdmin);
    error LocalBalanceTreeOverflow(
        uint32 originNetwork,
        address originTokenAddress,
        uint256 amount,
        uint256 localBalanceTreeAmount
    );
    error LocalBalanceTreeUnderflow(
        uint32 originNetwork,
        address originTokenAddress,
        uint256 amount,
        uint256 localBalanceTreeAmount
    );
    error MerkleTreeFull();
    error MessageFailed();
    error MsgValueNotZero();
    error NativeTokenIsEther();
    error NoValueInMessagesOnGasTokenNetworks();
    error NotValidAmount();
    error NotValidOwner();
    error NotValidSignature();
    error NotValidSpender();
    error OnlyBridgeManager();
    error OnlyEmergencyBridgePauser();
    error OnlyEmergencyBridgeUnpauser();
    error OnlyEmergencyState();
    error OnlyGlobalExitRootRemover();
    error OnlyNotEmergencyState();
    error OnlyPendingEmergencyBridgePauser();
    error OnlyPendingEmergencyBridgeUnpauser();
    error OnlyPendingProxiedTokensManager();
    error OnlyProxiedTokensManager();
    error OnlyRollupManager();
    error OriginNetworkInvalid();
    error SafeERC20FailedOperation(address token);
    error TokenAlreadyMapped();
    error TokenAlreadyUpdated();
    error TokenNotMapped();
    error TokenNotRemapped();
    error WETHRemappingNotSupportedOnGasTokenNetworks();
    event AcceptEmergencyBridgePauserRole(
        address oldEmergencyBridgePauser,
        address newEmergencyBridgePauser
    );
    event AcceptEmergencyBridgeUnpauserRole(
        address oldEmergencyBridgeUnpauser,
        address newEmergencyBridgeUnpauser
    );
    event AcceptProxiedTokensManagerRole(
        address oldProxiedTokensManager,
        address newProxiedTokensManager
    );
    event BridgeEvent(
        uint8 leafType,
        uint32 originNetwork,
        address originAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes metadata,
        uint32 depositCount
    );
    event ClaimEvent(
        uint256 globalIndex,
        uint32 originNetwork,
        address originAddress,
        address destinationAddress,
        uint256 amount
    );
    event EmergencyStateActivated();
    event EmergencyStateDeactivated();
    event Initialized(uint8 version);
    event MigrateLegacyToken(
        address sender,
        address legacyTokenAddress,
        address updatedTokenAddress,
        uint256 amount
    );
    event NewWrappedToken(
        uint32 originNetwork,
        address originTokenAddress,
        address wrappedTokenAddress,
        bytes metadata
    );
    event RemoveLegacySovereignTokenAddress(address sovereignTokenAddress);
    event SetBridgeManager(address bridgeManager);
    event SetSovereignTokenAddress(
        uint32 originNetwork,
        address originTokenAddress,
        address sovereignTokenAddress,
        bool isNotMintable
    );
    event SetSovereignWETHAddress(
        address sovereignWETHTokenAddress,
        bool isNotMintable
    );
    event TransferEmergencyBridgePauserRole(
        address currentEmergencyBridgePauser,
        address newEmergencyBridgePauser
    );
    event TransferEmergencyBridgeUnpauserRole(
        address currentEmergencyBridgeUnpauser,
        address newEmergencyBridgeUnpauser
    );
    event TransferProxiedTokensManagerRole(
        address currentProxiedTokensManager,
        address newProxiedTokensManager
    );
    event UpdatedClaimedGlobalIndexHashChain(
        bytes32 claimedGlobalIndex,
        bytes32 newClaimedGlobalIndexHashChain
    );
    event UpdatedUnsetGlobalIndexHashChain(
        bytes32 unsetGlobalIndex,
        bytes32 newUnsetGlobalIndexHashChain
    );

    function BRIDGE_SOVEREIGN_VERSION() external view returns (string memory);

    function BRIDGE_VERSION() external view returns (string memory);

    function INIT_BYTECODE_TRANSPARENT_PROXY()
        external
        view
        returns (bytes memory);

    function WETHToken() external view returns (address);

    function acceptEmergencyBridgePauserRole() external;

    function acceptEmergencyBridgeUnpauserRole() external;

    function acceptProxiedTokensManagerRole() external;

    function activateEmergencyState() external;

    function bridgeAsset(
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        address token,
        bool forceUpdateGlobalExitRoot,
        bytes memory permitData
    ) external payable;

    function bridgeManager() external view returns (address);

    function bridgeMessage(
        uint32 destinationNetwork,
        address destinationAddress,
        bool forceUpdateGlobalExitRoot,
        bytes memory metadata
    ) external payable;

    function bridgeMessageWETH(
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amountWETH,
        bool forceUpdateGlobalExitRoot,
        bytes memory metadata
    ) external;

    function calculateRoot(
        bytes32 leafHash,
        bytes32[32] memory smtProof,
        uint32 index
    ) external pure returns (bytes32);

    function claimAsset(
        bytes32[32] memory smtProofLocalExitRoot,
        bytes32[32] memory smtProofRollupExitRoot,
        uint256 globalIndex,
        bytes32 mainnetExitRoot,
        bytes32 rollupExitRoot,
        uint32 originNetwork,
        address originTokenAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes memory metadata
    ) external;

    function claimMessage(
        bytes32[32] memory smtProofLocalExitRoot,
        bytes32[32] memory smtProofRollupExitRoot,
        uint256 globalIndex,
        bytes32 mainnetExitRoot,
        bytes32 rollupExitRoot,
        uint32 originNetwork,
        address originAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes memory metadata
    ) external;

    function claimedBitMap(uint256) external view returns (uint256);

    function claimedGlobalIndexHashChain() external view returns (bytes32);

    function computeTokenProxyAddress(
        uint32 originNetwork,
        address originTokenAddress
    ) external view returns (address);

    function deactivateEmergencyState() external;

    function deployWrappedTokenAndRemap(
        uint32 originNetwork,
        address originTokenAddress,
        bool isNotMintable
    ) external;

    function depositCount() external view returns (uint256);

    function emergencyBridgePauser() external view returns (address);

    function emergencyBridgeUnpauser() external view returns (address);

    function gasTokenAddress() external view returns (address);

    function gasTokenMetadata() external view returns (bytes memory);

    function gasTokenNetwork() external view returns (uint32);

    function getLeafValue(
        uint8 leafType,
        uint32 originNetwork,
        address originAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes32 metadataHash
    ) external pure returns (bytes32);

    function getProxiedTokensManager() external view returns (address);

    function getRoot() external view returns (bytes32);

    function getTokenMetadata(address token)
        external
        view
        returns (bytes memory);

    function getTokenWrappedAddress(
        uint32 originNetwork,
        address originTokenAddress
    ) external view returns (address);

    function getWrappedTokenBridgeImplementation()
        external
        view
        returns (address);

    function globalExitRootManager() external view returns (address);

    function initialize(
        uint32 _networkID,
        address _gasTokenAddress,
        uint32 _gasTokenNetwork,
        address _globalExitRootManager,
        address _polygonRollupManager,
        bytes memory _gasTokenMetadata,
        address _bridgeManager,
        address _sovereignWETHAddress,
        bool _sovereignWETHAddressIsNotMintable,
        address _emergencyBridgePauser,
        address _emergencyBridgeUnpauser,
        address _proxiedTokensManager
    ) external;

    function initialize() external pure;

    function initialize(
        uint32,
        address,
        uint32,
        address,
        address,
        bytes memory
    ) external;

    function isClaimed(uint32 leafIndex, uint32 sourceBridgeNetwork)
        external
        view
        returns (bool);

    function isEmergencyState() external view returns (bool);

    function lastUpdatedDepositCount() external view returns (uint32);

    function localBalanceTree(bytes32 tokenInfoHash)
        external
        view
        returns (uint256 amount);

    function migrateLegacyToken(
        address legacyTokenAddress,
        uint256 amount,
        bytes memory permitData
    ) external;

    function networkID() external view returns (uint32);

    function pendingEmergencyBridgePauser() external view returns (address);

    function pendingEmergencyBridgeUnpauser() external view returns (address);

    function pendingProxiedTokensManager() external view returns (address);

    function polygonRollupManager() external view returns (address);

    function proxiedTokensManager() external view returns (address);

    function removeLegacySovereignTokenAddress(
        address legacySovereignTokenAddress
    ) external;

    function setBridgeManager(address _bridgeManager) external;

    function setMultipleSovereignTokenAddress(
        uint32[] memory originNetworks,
        address[] memory originTokenAddresses,
        address[] memory sovereignTokenAddresses,
        bool[] memory isNotMintable
    ) external;

    function setSovereignWETHAddress(
        address sovereignWETHTokenAddress,
        bool isNotMintable
    ) external;

    function tokenInfoToWrappedToken(bytes32) external view returns (address);

    function transferEmergencyBridgePauserRole(address newEmergencyBridgePauser)
        external;

    function transferEmergencyBridgeUnpauserRole(
        address newEmergencyBridgeUnpauser
    ) external;

    function transferProxiedTokensManagerRole(address newProxiedTokensManager)
        external;

    function unsetGlobalIndexHashChain() external view returns (bytes32);

    function unsetMultipleClaims(uint256[] memory globalIndexes) external;

    function updateGlobalExitRoot() external;

    function verifyMerkleProof(
        bytes32 leafHash,
        bytes32[32] memory smtProof,
        uint32 index,
        bytes32 root
    ) external pure returns (bool);

    function wrappedAddressIsNotMintable(address wrappedAddress)
        external
        view
        returns (bool isNotMintable);

    function wrappedTokenBytecodeStorer() external view returns (address);

    function wrappedTokenToTokenInfo(address)
        external
        view
        returns (uint32 originNetwork, address originTokenAddress);
}
