// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IRenderUtils
 * @notice Utility methods to get batch get full state of NFTs following 5773 (MultiAsset NFTs), 6220 (Equippable NFTs) and 7401 (Nestable NFTs) ERCs
 * @dev Interface for rendering and state retrieval of RMRK NFT collections
 * @custom:katana 0xA681A7BE7A87bDA505c1a947b172b8A1988E329A
 * @custom:bokuto 0xcd891c3de90dcdF99549E9B6402BFAa695DEc69B
 * @custom:tags nft,erc721,rmrk,rendering,utility
 */
interface IRenderUtils {
    error RMRKChildNotFoundInParent();
    error RMRKMismachedArrayLength();
    error RMRKNotComposableAsset();
    error RMRKParentIsNotNFT();
    error RMRKTokenHasNoAssets();
    error RMRKUnexpectedParent();

    function checkExpectedParent(
        address childAddress,
        uint256 childId,
        address expectedParent,
        uint256 expectedParentId
    ) external view;

    function composeEquippables(
        address target,
        uint256 tokenId,
        uint64 assetId
    )
        external
        view
        returns (
            string memory metadataURI,
            uint64 equippableGroupId,
            address catalogAddress,
            RMRKEquipRenderUtils.FixedPart[] memory fixedParts,
            RMRKEquipRenderUtils.EquippedSlotPart[] memory slotParts
        );

    function directOwnerOfWithParentsPerspective(
        address collection,
        uint256 tokenId
    )
        external
        view
        returns (
            address directOwner,
            uint256 ownerId,
            bool isNFT,
            bool inParentsActiveChildren,
            bool inParentsPendingChildren
        );

    function equippedChildrenOf(
        address parentAddress,
        uint256 parentId,
        uint64 parentAssetId
    ) external view returns (IERC6220.Equipment[] memory equippedChildren);

    function getAllEquippableSlotsFromParent(
        address targetChild,
        uint256 childId,
        bool onlyEquipped
    )
        external
        view
        returns (
            uint256 childIndex,
            RMRKEquipRenderUtils.EquippableData[] memory equippableData
        );

    function getAssetIdWithTopPriority(address target, uint256 tokenId)
        external
        view
        returns (uint64 maxPriorityAssetId, uint64 maxPriority);

    function getAssetsById(
        address target,
        uint256 tokenId,
        uint64[] memory assetIds
    ) external view returns (string[] memory assets);

    function getChildIndex(
        address parentAddress,
        uint256 parentId,
        address childAddress,
        uint256 childId
    ) external view returns (uint256 index);

    function getChildrenWithTopMetadata(address parentAddress, uint256 parentId)
        external
        view
        returns (
            RMRKEquipRenderUtils.ChildWithTopAssetMetadata[]
                memory childrenWithMetadata
        );

    function getEquippableSlotsFromParent(
        address childAddress,
        uint256 childId,
        address parentAddress,
        uint256 parentId,
        uint64 parentAssetId
    )
        external
        view
        returns (RMRKEquipRenderUtils.EquippableData[] memory equippableData);

    function getEquippableSlotsFromParent(
        address targetChild,
        uint256 childId,
        uint64 parentAssetId
    )
        external
        view
        returns (
            uint256 childIndex,
            RMRKEquipRenderUtils.EquippableData[] memory equippableData
        );

    function getEquippableSlotsFromParentForPendingChild(
        address targetChild,
        uint256 childId,
        uint64 parentAssetId
    )
        external
        view
        returns (
            uint256 childIndex,
            RMRKEquipRenderUtils.EquippableData[] memory equippableData
        );

    function getEquipped(
        address target,
        uint256 tokenId,
        uint64 assetId
    )
        external
        view
        returns (
            uint64[] memory slotPartIds,
            IERC6220.Equipment[] memory childrenEquipped,
            string[] memory childrenAssetMetadata
        );

    function getExtendedActiveAssets(address target, uint256 tokenId)
        external
        view
        returns (
            RMRKMultiAssetRenderUtils.ExtendedActiveAsset[] memory activeAssets
        );

    function getExtendedEquippableActiveAssets(address target, uint256 tokenId)
        external
        view
        returns (
            RMRKEquipRenderUtils.ExtendedEquippableActiveAsset[]
                memory activeAssets
        );

    function getExtendedNft(uint256 tokenId, address targetCollection)
        external
        view
        returns (RMRKRenderUtils.ExtendedNft memory data);

    function getExtendedPendingAssets(address target, uint256 tokenId)
        external
        view
        returns (
            RMRKEquipRenderUtils.ExtendedPendingAsset[] memory pendingAssets
        );

    function getParent(address childAddress, uint256 childId)
        external
        view
        returns (address parentAddress, uint256 parentId);

    function getPendingAssets(address target, uint256 tokenId)
        external
        view
        returns (RMRKMultiAssetRenderUtils.PendingAsset[] memory pendingAssets);

    function getPendingChildIndex(
        address parentAddress,
        uint256 parentId,
        address childAddress,
        uint256 childId
    ) external view returns (uint256 index);

    function getSlotPartsAndCatalog(
        address tokenAddress,
        uint256 tokenId,
        uint64 assetId
    )
        external
        view
        returns (uint64[] memory parentSlotPartIds, address catalogAddress);

    function getTopAsset(address target, uint256 tokenId)
        external
        view
        returns (
            uint64 topAssetId,
            uint64 topAssetPriority,
            string memory topAssetMetadata
        );

    function getTopAssetAndEquippableDataForToken(
        address target,
        uint256 tokenId
    )
        external
        view
        returns (
            RMRKEquipRenderUtils.ExtendedEquippableActiveAsset memory topAsset
        );

    function getTopAssetMetaForToken(address target, uint256 tokenId)
        external
        view
        returns (string memory metadata);

    function getTopAssetMetadataForTokens(
        address target,
        uint256[] memory tokenIds
    ) external view returns (string[] memory metadata);

    function getTotalDescendants(address collection, uint256 tokenId)
        external
        view
        returns (uint256 totalDescendants, bool hasMoreThanOneLevelOfNesting_);

    function hasMoreThanOneLevelOfNesting(address collection, uint256 tokenId)
        external
        view
        returns (bool hasMoreThanOneLevelOfNesting_);

    function isAssetEquipped(
        address parentAddress,
        uint256 parentId,
        address parentAssetCatalog,
        address childAddress,
        uint256 childId,
        uint64 childAssetId,
        uint64 slotPartId
    ) external view returns (bool isEquipped);

    function isTokenRejectedOrAbandoned(address collection, uint256 tokenId)
        external
        view
        returns (bool isRejectedOrAbandoned);

    function splitSlotAndFixedParts(
        uint64[] memory allPartIds,
        address catalogAddress
    )
        external
        view
        returns (uint64[] memory slotPartIds, uint64[] memory fixedPartIds);

    function validateChildOf(
        address parentAddress,
        address childAddress,
        uint256 parentId,
        uint256 childId
    ) external view returns (bool validChild);

    function validateChildrenOf(
        address parentAddress,
        address[] memory childAddresses,
        uint256 parentId,
        uint256[] memory childIds
    ) external view returns (bool isValid, bool[] memory validityOfChildren);
}

interface RMRKEquipRenderUtils {
    struct FixedPart {
        uint64 partId;
        uint8 z;
        string metadataURI;
    }

    struct EquippedSlotPart {
        uint64 partId;
        uint64 childAssetId;
        uint8 z;
        address childAddress;
        uint256 childId;
        string childAssetMetadata;
        string partMetadata;
    }

    struct EquippableData {
        uint64 slotPartId;
        uint64 childAssetId;
        uint64 parentAssetId;
        uint64 priority;
        address parentCatalogAddress;
        bool isEquipped;
        string partMetadata;
        string childAssetMetadata;
        string parentAssetMetadata;
    }

    struct ChildWithTopAssetMetadata {
        address contractAddress;
        uint256 tokenId;
        string metadata;
    }

    struct ExtendedEquippableActiveAsset {
        uint64 id;
        uint64 equippableGroupId;
        uint64 priority;
        address catalogAddress;
        string metadata;
        uint64[] partIds;
    }

    struct ExtendedPendingAsset {
        uint64 id;
        uint64 equippableGroupId;
        uint128 acceptRejectIndex;
        uint64 replacesAssetWithId;
        address catalogAddress;
        string metadata;
        uint64[] partIds;
    }
}

interface IERC6220 {
    struct Equipment {
        uint64 assetId;
        uint64 childAssetId;
        uint256 childId;
        address childEquippableAddress;
    }
}

interface RMRKMultiAssetRenderUtils {
    struct ExtendedActiveAsset {
        uint64 id;
        uint64 priority;
        string metadata;
    }

    struct PendingAsset {
        uint64 id;
        uint128 acceptRejectIndex;
        uint64 replacesAssetWithId;
        string metadata;
    }
}

interface RMRKRenderUtils {
    struct ExtendedNft {
        string tokenMetadataUri;
        address directOwner;
        address rootOwner;
        uint256 activeAssetCount;
        uint256 pendingAssetCount;
        uint64[] priorities;
        uint256 maxSupply;
        uint256 totalSupply;
        address issuer;
        string name;
        string symbol;
        uint256 activeChildrenNumber;
        uint256 pendingChildrenNumber;
        bool isSoulbound;
        bool hasMultiAssetInterface;
        bool hasNestingInterface;
        bool hasEquippableInterface;
    }
}